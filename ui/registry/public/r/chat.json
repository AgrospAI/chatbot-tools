{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chat",
  "title": "Chat",
  "description": "A customizable chat component.",
  "dependencies": [
    "class-variance-authority",
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "avatar"
  ],
  "files": [
    {
      "path": "src/registry/new-york/chat/components/autosize-textarea.tsx",
      "content": "\"use client\";\nimport { cn } from \"@/lib/utils\";\nimport * as React from \"react\";\nimport { useImperativeHandle } from \"react\";\n\ninterface UseAutosizeTextAreaProps {\n  textAreaRef: React.RefObject<HTMLTextAreaElement | null>;\n  minHeight?: number;\n  maxHeight?: number;\n  triggerAutoSize: string;\n}\n\nexport const useAutosizeTextArea = ({\n  textAreaRef,\n  triggerAutoSize,\n  maxHeight = Number.MAX_SAFE_INTEGER,\n  minHeight = 0,\n}: UseAutosizeTextAreaProps) => {\n  const [init, setInit] = React.useState(true);\n  React.useEffect(() => {\n    // We need to reset the height momentarily to get the correct scrollHeight for the textarea\n    const offsetBorder = 2;\n    const textArea = textAreaRef.current;\n    if (textArea) {\n      if (init) {\n        textArea.style.minHeight = `${minHeight + offsetBorder}px`;\n        if (maxHeight > minHeight) {\n          textArea.style.maxHeight = `${maxHeight}px`;\n        }\n        setInit(false);\n      }\n      textArea.style.height = `${minHeight + offsetBorder}px`;\n      const scrollHeight = textArea.scrollHeight;\n      // We then set the height directly, outside of the render loop\n      // Trying to set this with state or a ref will product an incorrect value.\n      if (scrollHeight > maxHeight) {\n        textArea.style.height = `${maxHeight}px`;\n      } else {\n        textArea.style.height = `${scrollHeight + offsetBorder}px`;\n      }\n    }\n  }, [init, maxHeight, minHeight, textAreaRef, triggerAutoSize]);\n};\n\nexport type AutosizeTextAreaRef = {\n  textArea: HTMLTextAreaElement;\n  maxHeight: number;\n  minHeight: number;\n};\n\nexport interface AutosizeTextAreaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {\n  maxHeight?: number;\n  minHeight?: number;\n}\n\nexport const AutosizeTextarea = React.forwardRef<\n  AutosizeTextAreaRef,\n  AutosizeTextAreaProps\n>(\n  (\n    {\n      maxHeight = Number.MAX_SAFE_INTEGER,\n      minHeight = 0,\n      className,\n      onChange,\n      value,\n      ...props\n    }: AutosizeTextAreaProps,\n    ref: React.Ref<AutosizeTextAreaRef>,\n  ) => {\n    const textAreaRef = React.useRef<HTMLTextAreaElement | null>(null);\n    const [triggerAutoSize, setTriggerAutoSize] = React.useState(\"\");\n\n    useAutosizeTextArea({\n      textAreaRef,\n      triggerAutoSize,\n      maxHeight,\n      minHeight,\n    });\n\n    useImperativeHandle(ref, () => ({\n      textArea: textAreaRef.current as HTMLTextAreaElement,\n      focus: () => textAreaRef?.current?.focus(),\n      maxHeight,\n      minHeight,\n    }));\n\n    React.useEffect(() => {\n      setTriggerAutoSize(value as string);\n    }, [props?.defaultValue, value]);\n\n    return (\n      <textarea\n        {...props}\n        value={value}\n        ref={textAreaRef}\n        className={cn(\n          \"flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-muted-foreground/30 focus-visible:ring-offset-1 disabled:cursor-not-allowed disabled:opacity-50\",\n          \"overflow-y-auto\",\n          className,\n        )}\n        style={{\n          ...props.style,\n          scrollbarWidth: 'thin',\n          scrollbarColor: 'hsl(var(--primary)) transparent'\n        }}\n        onChange={(e) => {\n          setTriggerAutoSize(e.target.value);\n          onChange?.(e);\n        }}\n      />\n    );\n  },\n);\nAutosizeTextarea.displayName = \"AutosizeTextarea\";",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/new-york/chat/components/chat-bubble.tsx",
      "content": "import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { cn } from \"@/lib/utils\"\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\"\nimport MessageLoading from \"@/registry/new-york/chat/components/message-loading\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\n\n// ChatBubble\nconst chatBubbleVariant = cva(\n  \"flex gap-2 max-w-[calc(100%-2rem)] items-start relative group\",\n  {\n    variants: {\n      variant: {\n        received: \"self-start\",\n        sent: \"self-end flex-row-reverse\",\n      },\n      layout: {\n        default: \"\",\n        ai: \"max-w-full w-full items-center\",\n      },\n    },\n    defaultVariants: {\n      variant: \"received\",\n      layout: \"default\",\n    },\n  },\n)\n\ninterface ChatBubbleProps\n  extends\n    React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof chatBubbleVariant> {}\n\nconst ChatBubble = React.forwardRef<HTMLDivElement, ChatBubbleProps>(\n  ({ className, variant, layout, children, ...props }, ref) => (\n    <div\n      className={cn(\n        chatBubbleVariant({ variant, layout, className }),\n        \"group relative\",\n      )}\n      ref={ref}\n      {...props}\n    >\n      {React.Children.map(children, child =>\n        React.isValidElement(child) && typeof child.type !== \"string\"\n          ? React.cloneElement(child, {\n              variant,\n              layout,\n            } as React.ComponentProps<typeof child.type>)\n          : child,\n      )}\n    </div>\n  ),\n)\nChatBubble.displayName = \"ChatBubble\"\n\n// ChatBubbleAvatar\ninterface ChatBubbleAvatarProps {\n  src?: string\n  fallback?: string | React.ReactNode\n  className?: string\n}\n\nconst ChatBubbleAvatar: React.FC<ChatBubbleAvatarProps> = ({\n  src,\n  fallback,\n  className,\n}) => (\n  <Avatar className={className}>\n    <AvatarImage src={src} alt=\"Avatar\" />\n    <AvatarFallback>{fallback}</AvatarFallback>\n  </Avatar>\n)\n\n// ChatBubbleMessage\nconst chatBubbleMessageVariants = cva(\"p-4\", {\n  variants: {\n    variant: {\n      received: \"bg-muted rounded-r-lg rounded-bl-lg\",\n      sent: \"bg-primary text-primary-foreground rounded-l-lg rounded-br-lg\",\n    },\n    layout: {\n      default: \"\",\n      ai: \"border-t w-full rounded-none bg-transparent\",\n    },\n  },\n  defaultVariants: {\n    variant: \"received\",\n    layout: \"default\",\n  },\n})\n\ninterface ChatBubbleMessageProps\n  extends\n    React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof chatBubbleMessageVariants> {\n  isLoading?: boolean\n}\n\nconst ChatBubbleMessage = React.forwardRef<\n  HTMLDivElement,\n  ChatBubbleMessageProps\n>(\n  (\n    { className, variant, layout, isLoading = false, children, ...props },\n    ref,\n  ) => (\n    <div\n      className={cn(\n        chatBubbleMessageVariants({ variant, layout, className }),\n        \"max-w-full break-words\",\n      )}\n      ref={ref}\n      {...props}\n    >\n      {isLoading ? (\n        <div className=\"flex items-center space-x-2\">\n          <MessageLoading />\n        </div>\n      ) : (\n        children\n      )}\n    </div>\n  ),\n)\nChatBubbleMessage.displayName = \"ChatBubbleMessage\"\n\n// ChatBubbleTimestamp\ninterface ChatBubbleTimestampProps extends React.HTMLAttributes<HTMLDivElement> {\n  timestamp: string\n}\n\nconst ChatBubbleTimestamp: React.FC<ChatBubbleTimestampProps> = ({\n  timestamp,\n  className,\n  ...props\n}) => (\n  <div className={cn(\"mt-2 text-right text-xs\", className)} {...props}>\n    {timestamp}\n  </div>\n)\n\n// ChatBubbleAction\ninterface ButtonProps\n  extends\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\ntype ChatBubbleActionProps = ButtonProps & {\n  icon: React.ReactNode\n}\n\nconst ChatBubbleAction: React.FC<ChatBubbleActionProps> = ({\n  icon,\n  onClick,\n  className,\n  variant = \"ghost\",\n  size = \"icon\",\n  ...props\n}) => (\n  <Button\n    variant={variant}\n    size={size}\n    className={className}\n    onClick={onClick}\n    {...props}\n  >\n    {icon}\n  </Button>\n)\n\ninterface ChatBubbleActionWrapperProps extends React.HTMLAttributes<HTMLDivElement> {\n  variant?: \"sent\" | \"received\"\n  className?: string\n}\n\nconst ChatBubbleActionWrapper = React.forwardRef<\n  HTMLDivElement,\n  ChatBubbleActionWrapperProps\n>(({ variant, className, children, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"absolute top-1/2 flex -translate-y-1/2 opacity-0 transition-opacity duration-200 group-hover:opacity-100\",\n      variant === \"sent\"\n        ? \"-left-1 -translate-x-full flex-row-reverse\"\n        : \"-right-1 translate-x-full\",\n      className,\n    )}\n    {...props}\n  >\n    {children}\n  </div>\n))\nChatBubbleActionWrapper.displayName = \"ChatBubbleActionWrapper\"\n\nexport {\n  ChatBubble,\n  ChatBubbleAvatar,\n  ChatBubbleMessage,\n  ChatBubbleTimestamp,\n  chatBubbleVariant,\n  chatBubbleMessageVariants,\n  ChatBubbleAction,\n  ChatBubbleActionWrapper,\n}\n",
      "type": "registry:component",
      "target": "~/components/chat/"
    },
    {
      "path": "src/registry/new-york/chat/components/chat-input.tsx",
      "content": "import * as React from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport {\n  AutosizeTextarea,\n  type AutosizeTextAreaRef,\n} from \"@/registry/new-york/chat/components/autosize-textarea\"\n\ntype ChatInputProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>\n\nconst ChatInput = React.forwardRef<AutosizeTextAreaRef, ChatInputProps>(\n  ({ className, ...props }, ref) => (\n    <AutosizeTextarea\n      ref={ref}\n      name=\"message\"\n      autoComplete=\"off\"\n      className={cn(\n        \"flex w-full resize-none rounded-none px-4 py-3 text-sm shadow-none border-0\",\n        \"placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        \"outline-none focus:outline-none focus-visible:outline-none\",\n        \"ring-0 focus:ring-0 focus-visible:ring-0\",\n        \"ring-offset-0 focus:ring-offset-0 focus-visible:ring-offset-0\",\n        className,\n      )}\n      maxHeight={192}\n      {...props}\n    />\n  ),\n)\nChatInput.displayName = \"ChatInput\"\n\nexport { ChatInput }\n",
      "type": "registry:component",
      "target": "~/components/chat/"
    },
    {
      "path": "src/registry/new-york/chat/components/chat-message-list.tsx",
      "content": "import * as React from \"react\"\nimport { ArrowDown } from \"lucide-react\"\nimport { Button } from \"@/components/ui/button\"\nimport { useAutoScroll } from \"@/registry/new-york/chat/hooks/useAutoScroll\"\n\ninterface ChatMessageListProps extends React.HTMLAttributes<HTMLDivElement> {\n  smooth?: boolean\n}\n\nconst ChatMessageList = React.forwardRef<HTMLDivElement, ChatMessageListProps>(\n  ({ className, children, smooth = false, ...props }, ref) => {\n    const { scrollRef, isAtBottom, scrollToBottom, disableAutoScroll } =\n      useAutoScroll({\n        smooth,\n        content: children,\n      })\n\n    // Merge the forwarded ref with scrollRef\n    const mergedRef = React.useCallback(\n      (node: HTMLDivElement | null) => {\n        scrollRef.current = node\n        if (typeof ref === \"function\") {\n          ref(node)\n        } else if (ref) {\n          ref.current = node\n        }\n      },\n      [ref, scrollRef]\n    )\n\n    return (\n      <div className=\"relative\">\n        <div\n          className={`mx-auto flex h-full w-full flex-col overflow-y-auto p-4 ${className}`}\n          ref={mergedRef}\n          onWheel={disableAutoScroll}\n          onTouchMove={disableAutoScroll}\n          style={{\n            scrollBehavior: smooth ? \"smooth\" : \"auto\",\n          }}\n          {...props}\n        >\n          <div className=\"flex flex-col gap-6\">{children}</div>\n        </div>\n\n        {!isAtBottom && (\n          <Button\n            onClick={() => {\n              scrollToBottom()\n            }}\n            size=\"icon\"\n            variant=\"outline\"\n            className=\"absolute bottom-2 left-1/2 inline-flex -translate-x-1/2 transform rounded-full shadow-md\"\n            aria-label=\"Scroll to bottom\"\n          >\n            <ArrowDown className=\"h-4 w-4\" />\n          </Button>\n        )}\n      </div>\n    )\n  },\n)\n\nChatMessageList.displayName = \"ChatMessageList\"\n\nexport { ChatMessageList }\n",
      "type": "registry:component",
      "target": "~/components/chat/"
    },
    {
      "path": "src/registry/new-york/chat/components/expandable-chat.tsx",
      "content": "\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport { useLockBodyScroll } from \"@/registry/new-york/chat/hooks/useLockBodyScroll\"\nimport useMediaQuery from \"@/registry/new-york/chat/hooks/useMediaQuery\"\nimport { cn } from \"@/lib/utils\"\nimport { BotMessageSquare, Expand, Minimize, X } from \"lucide-react\"\nimport React, { createContext, useContext, useRef, useState } from \"react\"\nimport { createPortal } from \"react-dom\"\n\ninterface ExpandableChatProps extends React.HTMLAttributes<HTMLDivElement> {\n  icon?: React.ReactNode\n}\n\nconst ChatContext = createContext<\n  | {\n      isOpen: boolean\n      toggleChat: () => void\n      isFullscreen: boolean\n      toggleFullscreen: () => void\n    }\n  | undefined\n>(undefined)\n\nexport const useChat = () => {\n  const context = useContext(ChatContext)\n  if (!context) throw new Error(\"useChat must be used within ExpandableChat\")\n  return context\n}\n\nconst ExpandableChat: React.FC<ExpandableChatProps> = ({\n  className,\n  icon,\n  children,\n  ...props\n}) => {\n  const [isOpen, setIsOpen] = useState(false)\n  const chatRef = useRef<HTMLDivElement>(null)\n\n  const toggleChat = () => setIsOpen(!isOpen)\n\n  const [userIsFullscreen, setUserIsFullscreen] = useState(false)\n  const toggleFullscreen = () => setUserIsFullscreen(!userIsFullscreen)\n\n  const isSmallScreen = useMediaQuery(\"(max-width: 640px)\")\n  const isFullscreen = isOpen && (userIsFullscreen || isSmallScreen)\n\n  useLockBodyScroll(isOpen)\n\n  return createPortal(\n    <ChatContext.Provider\n      value={{ isOpen, toggleChat, isFullscreen, toggleFullscreen }}\n    >\n      <div\n        className={cn(\n          `fixed inset-0 isolate z-[999]`,\n          isOpen ? \"bg-black/20\" : \"pointer-events-none\",\n          className,\n        )}\n        onClick={e => {\n          e.stopPropagation()\n          if (e.target === e.currentTarget && isOpen) {\n            toggleChat()\n          }\n        }}\n        {...props}\n      >\n        <div\n          ref={chatRef}\n          className={cn(\n            \"pointer-events-auto fixed right-4 bottom-24 flex h-[80vh] w-full max-w-xl origin-bottom-right flex-col overflow-hidden rounded-2xl border bg-background shadow-md transition-all duration-300 ease-in-out\",\n            isOpen\n              ? \"scale-100 opacity-100\"\n              : \"pointer-events-none scale-0 opacity-0\",\n            isFullscreen\n              ? \"right-0 bottom-0 h-full w-full max-w-3xl rounded-none rounded-l-md shadow-lg\"\n              : \"\",\n            className,\n          )}\n        >\n          {children}\n        </div>\n        {!isFullscreen && (\n          <ExpandableChatToggle\n            icon={icon}\n            isOpen={isOpen}\n            toggleChat={toggleChat}\n            className=\"pointer-events-auto absolute right-4 bottom-4 z-[800]\"\n          />\n        )}\n      </div>\n    </ChatContext.Provider>,\n    document.body,\n  )\n}\n\nExpandableChat.displayName = \"ExpandableChat\"\n\nconst ExpandableChatHeader: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({\n  className,\n  ...props\n}) => {\n  const { toggleChat, isFullscreen, toggleFullscreen } = useChat()\n\n  const isSmallScreen = useMediaQuery(\"(max-width: 640px)\")\n\n  return (\n    <div\n      className={cn(\n        \"flex items-center gap-2 border-b py-2 pr-13 pl-2\",\n        className,\n      )}\n      {...props}\n    >\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        onClick={isSmallScreen ? toggleChat : toggleFullscreen}\n      >\n        {isSmallScreen ? (\n          <X className=\"size-4\" />\n        ) : isFullscreen ? (\n          <Minimize className=\"size-4\" />\n        ) : (\n          <Expand className=\"size-4\" />\n        )}\n      </Button>\n      {props.children}\n    </div>\n  )\n}\n\nExpandableChatHeader.displayName = \"ExpandableChatHeader\"\n\nconst ExpandableChatBody: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({\n  className,\n  ...props\n}) => <div className={cn(\"flex-grow overflow-y-auto\", className)} {...props} />\n\nExpandableChatBody.displayName = \"ExpandableChatBody\"\n\nconst ExpandableChatFooter: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({\n  className,\n  ...props\n}) => (\n  <div\n    className={cn(\n      \"relative mx-auto w-full max-w-3xl p-2\",\n      \"before:absolute before:-top-6 before:right-0 before:left-0 before:h-6\",\n      \"before:bg-gradient-to-t before:from-background before:to-transparent\",\n      \"before:pointer-events-none before:z-10\",\n      className,\n    )}\n    {...props}\n  />\n)\n\nExpandableChatFooter.displayName = \"ExpandableChatFooter\"\n\ninterface ExpandableChatToggleProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  icon?: React.ReactNode\n  isOpen: boolean\n  toggleChat: () => void\n}\n\nconst ExpandableChatToggle: React.FC<ExpandableChatToggleProps> = ({\n  className,\n  icon,\n  isOpen,\n  toggleChat,\n  ...props\n}) => (\n  <Button\n    variant=\"default\"\n    onClick={toggleChat}\n    className={cn(\n      \"mr-2 mb-2 ml-auto flex h-14 w-14 cursor-pointer items-center justify-center rounded-full bg-primary shadow-md transition-all duration-300 hover:shadow-lg hover:shadow-black/30\",\n      className,\n    )}\n    {...props}\n  >\n    {isOpen ? (\n      <X className=\"size-5\" />\n    ) : (\n      icon || <BotMessageSquare className=\"size-6\" />\n    )}\n  </Button>\n)\n\nExpandableChatToggle.displayName = \"ExpandableChatToggle\"\n\nexport {\n  ExpandableChat,\n  ExpandableChatBody,\n  ExpandableChatFooter,\n  ExpandableChatHeader,\n}\n",
      "type": "registry:component",
      "target": "~/components/chat/"
    },
    {
      "path": "src/registry/new-york/chat/components/message-loading.tsx",
      "content": "// @hidden\nexport default function MessageLoading() {\n  return (\n    <svg\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className=\"text-foreground\"\n    >\n      <circle cx=\"4\" cy=\"12\" r=\"2\" fill=\"currentColor\">\n        <animate\n          id=\"spinner_qFRN\"\n          begin=\"0;spinner_OcgL.end+0.25s\"\n          attributeName=\"cy\"\n          calcMode=\"spline\"\n          dur=\"0.6s\"\n          values=\"12;6;12\"\n          keySplines=\".33,.66,.66,1;.33,0,.66,.33\"\n        />\n      </circle>\n      <circle cx=\"12\" cy=\"12\" r=\"2\" fill=\"currentColor\">\n        <animate\n          begin=\"spinner_qFRN.begin+0.1s\"\n          attributeName=\"cy\"\n          calcMode=\"spline\"\n          dur=\"0.6s\"\n          values=\"12;6;12\"\n          keySplines=\".33,.66,.66,1;.33,0,.66,.33\"\n        />\n      </circle>\n      <circle cx=\"20\" cy=\"12\" r=\"2\" fill=\"currentColor\">\n        <animate\n          id=\"spinner_OcgL\"\n          begin=\"spinner_qFRN.begin+0.2s\"\n          attributeName=\"cy\"\n          calcMode=\"spline\"\n          dur=\"0.6s\"\n          values=\"12;6;12\"\n          keySplines=\".33,.66,.66,1;.33,0,.66,.33\"\n        />\n      </circle>\n    </svg>\n  )\n}\n",
      "type": "registry:component",
      "target": "~/components/chat/"
    },
    {
      "path": "src/registry/new-york/chat/hooks/useAutoScroll.ts",
      "content": "// @hidden\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\ninterface ScrollState {\n  isAtBottom: boolean\n  autoScrollEnabled: boolean\n}\n\ninterface UseAutoScrollOptions {\n  offset?: number\n  smooth?: boolean\n  content?: React.ReactNode\n}\n\nexport function useAutoScroll(options: UseAutoScrollOptions = {}) {\n  const { offset = 20, smooth = false, content } = options\n  const scrollRef = useRef<HTMLDivElement>(null)\n  const lastContentHeight = useRef(0)\n  const userHasScrolled = useRef(false)\n\n  const [scrollState, setScrollState] = useState<ScrollState>({\n    isAtBottom: true,\n    autoScrollEnabled: true,\n  })\n\n  const checkIsAtBottom = useCallback(\n    (element: HTMLElement) => {\n      const { scrollTop, scrollHeight, clientHeight } = element\n      const distanceToBottom = Math.abs(scrollHeight - scrollTop - clientHeight)\n      return distanceToBottom <= offset\n    },\n    [offset],\n  )\n\n  const scrollToBottom = useCallback(\n    (instant?: boolean) => {\n      if (!scrollRef.current) return\n\n      const targetScrollTop =\n        scrollRef.current.scrollHeight - scrollRef.current.clientHeight\n\n      if (instant) {\n        scrollRef.current.scrollTop = targetScrollTop\n      } else {\n        scrollRef.current.scrollTo({\n          top: targetScrollTop,\n          behavior: smooth ? \"smooth\" : \"auto\",\n        })\n      }\n\n      setScrollState({\n        isAtBottom: true,\n        autoScrollEnabled: true,\n      })\n      userHasScrolled.current = false\n    },\n    [smooth],\n  )\n\n  const handleScroll = useCallback(() => {\n    if (!scrollRef.current) return\n\n    const atBottom = checkIsAtBottom(scrollRef.current)\n\n    setScrollState(prev => ({\n      isAtBottom: atBottom,\n      // Re-enable auto-scroll if at the bottom\n      autoScrollEnabled: atBottom ? true : prev.autoScrollEnabled,\n    }))\n  }, [checkIsAtBottom])\n\n  useEffect(() => {\n    const element = scrollRef.current\n    if (!element) return\n\n    element.addEventListener(\"scroll\", handleScroll, { passive: true })\n    return () => element.removeEventListener(\"scroll\", handleScroll)\n  }, [handleScroll])\n\n  useEffect(() => {\n    const scrollElement = scrollRef.current\n    if (!scrollElement) return\n\n    const currentHeight = scrollElement.scrollHeight\n    const hasNewContent = currentHeight !== lastContentHeight.current\n\n    if (hasNewContent) {\n      if (scrollState.autoScrollEnabled) {\n        requestAnimationFrame(() => {\n          scrollToBottom(lastContentHeight.current === 0)\n        })\n      }\n      lastContentHeight.current = currentHeight\n    }\n  }, [content, scrollState.autoScrollEnabled, scrollToBottom])\n\n  useEffect(() => {\n    const element = scrollRef.current\n    if (!element) return\n\n    const resizeObserver = new ResizeObserver(() => {\n      if (scrollState.autoScrollEnabled) {\n        scrollToBottom(true)\n      }\n    })\n\n    resizeObserver.observe(element)\n    return () => resizeObserver.disconnect()\n  }, [scrollState.autoScrollEnabled, scrollToBottom])\n\n  const disableAutoScroll = useCallback(() => {\n    const atBottom = scrollRef.current\n      ? checkIsAtBottom(scrollRef.current)\n      : false\n\n    // Only disable if not at bottom\n    if (!atBottom) {\n      userHasScrolled.current = true\n      setScrollState(prev => ({\n        ...prev,\n        autoScrollEnabled: false,\n      }))\n    }\n  }, [checkIsAtBottom])\n\n  return {\n    scrollRef,\n    isAtBottom: scrollState.isAtBottom,\n    autoScrollEnabled: scrollState.autoScrollEnabled,\n    scrollToBottom: () => scrollToBottom(false),\n    disableAutoScroll,\n  }\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/registry/new-york/chat/hooks/useLockBodyScroll.ts",
      "content": "import { useEffect } from \"react\"\n\nexport function useLockBodyScroll(lock: boolean = true): void {\n  useEffect(() => {\n    document.body.style.overflow = lock ? \"hidden\" : \"visible\"\n    return () => {\n      document.body.style.overflow = \"visible\"\n    }\n  }, [lock])\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "src/registry/new-york/chat/hooks/useMediaQuery.ts",
      "content": "import { useMemo, useState, useEffect } from \"react\"\n\nexport function useMediaQuery(query: string) {\n  const normalizedQuery = query.startsWith(\"@media\")\n    ? query.substring(\"@media\".length, query.length)\n    : query\n  const mediaQueryList = useMemo(\n    () => matchMedia(normalizedQuery),\n    [normalizedQuery],\n  )\n  const [matches, setMatches] = useState(mediaQueryList.matches)\n\n  useEffect(() => {\n    const handleChange = (e: MediaQueryListEvent) => {\n      setMatches(e.matches)\n    }\n\n    mediaQueryList.addEventListener(\"change\", handleChange)\n\n    return () => {\n      mediaQueryList.removeEventListener(\"change\", handleChange)\n    }\n  }, [mediaQueryList])\n\n  return matches\n}\n\nexport default useMediaQuery\n",
      "type": "registry:hook"
    }
  ],
  "type": "registry:component"
}