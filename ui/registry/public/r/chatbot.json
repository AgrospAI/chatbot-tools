{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chatbot",
  "title": "Chatbot",
  "description": "A customizable chatbot component.",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "button",
    "https://agrospai.github.io/chatbot-tools/r/chat.json"
  ],
  "files": [
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/chatbot.tsx",
      "content": "import { Button } from \"@/components/ui/button\"\nimport {\n  ChatBubble,\n  ChatBubbleMessage,\n} from \"@/registry/new-york/chat/components/chat/chat-bubble\"\nimport { ChatInput } from \"@/registry/new-york/chat/components/chat/chat-input\"\nimport { ChatMessageList } from \"@/registry/new-york/chat/components/chat/chat-message-list\"\nimport {\n  ExpandableChat,\n  ExpandableChatBody,\n  ExpandableChatFooter,\n  ExpandableChatHeader,\n} from \"@/registry/new-york/chat/components/chat/expandable-chat\"\nimport Markdown from \"@/registry/new-york/chat/components/chat/markdown/markdown\"\nimport PromptSuggestions from \"@/registry/new-york/chatbot/components/chatbot/prompt-suggestions\"\nimport { Send, Trash } from \"lucide-react\"\nimport { useState } from \"react\"\n\nexport type Message = UserMessage | BotMessage\n\nexport interface UserMessage {\n  role: \"user\"\n  message: string\n}\nexport interface BotMessage {\n  role: \"bot\"\n  message: string\n  pending: boolean\n  sources: string[]\n}\n\nexport type ChatStrings = {\n  title: string\n  promptSuggestions: string[]\n  placeholder: string\n  interruptedStreamingError: string\n  genericErrorAnswer: string\n}\n\nexport interface ChatbotProps {\n  endpoint?: string\n  strings?: Partial<ChatStrings>\n  messages: Message[]\n  icon?: React.ReactNode\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>\n  newChat?: () => Promise<void>\n}\n\nexport default function Chatbot({\n  endpoint = \"http://localhost:8000/ask\",\n  strings,\n  messages,\n  icon,\n  setMessages,\n  newChat,\n}: ChatbotProps) {\n  const title = strings?.title ?? \"Chatbot Assistant\"\n  const promptSuggestions = strings?.promptSuggestions ?? []\n  const placeholder = strings?.placeholder ?? \"Ask me anything...\"\n  const interruptedStreamingError =\n    strings?.interruptedStreamingError ?? \"(Response was interrupted)\"\n  const genericErrorAnswer =\n    strings?.genericErrorAnswer ??\n    \"Sorry, at this moment I am not able to help you. Try again later.\"\n\n  const [input, setInput] = useState(\"\")\n  const [isLoading, setIsLoading] = useState(false)\n  const [isStreaming, setIsStreaming] = useState(false)\n\n  const handleSendMessage = async (input: string) => {\n    setInput(\"\")\n\n    const userMessage = {\n      role: \"user\",\n      message: input,\n    } as UserMessage\n\n    const botMessage = {\n      role: \"bot\",\n      message: \"\",\n      pending: true,\n    } as BotMessage\n\n    setMessages(messages => [...messages, userMessage, botMessage])\n\n    setIsLoading(true)\n    setIsStreaming(true)\n\n    try {\n      const response = await fetch(endpoint, {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ question: input }),\n      })\n\n      if (!response.ok || !response.body) {\n        throw response.statusText\n      }\n\n      const reader = response.body.getReader()\n      const decoder = new TextDecoder()\n\n      let buffer = \"\"\n      let content = \"\"\n      let sources: string[] = []\n\n      while (true) {\n        const { value, done } = await reader.read()\n        if (done) {\n          setMessages(prev => {\n            const lastIndex = prev.length - 1\n            return prev.map((msg, i) =>\n              i === lastIndex\n                ? {\n                    ...msg,\n                    pending: false,\n                  }\n                : msg,\n            )\n          })\n          break\n        }\n        buffer += decoder.decode(value, { stream: true })\n        const lines = buffer.split(\"\\n\")\n        buffer = lines.pop() || \"\"\n\n        for (const line of lines) {\n          const message = line.replace(/^data: /, \"\").trim()\n          if (!message) continue\n\n          try {\n            const parsed = JSON.parse(message)\n\n            switch (parsed.type) {\n              case \"sources\":\n                sources = parsed.data\n                break\n              case \"token\":\n                content += parsed.data\n                break\n            }\n          } catch (e) {\n            console.error(\"Error parsing JSON chunk\", e)\n          }\n        }\n\n        if (content) {\n          setMessages(prev => {\n            const lastIndex = prev.length - 1\n            return prev.map((msg, i) => {\n              const isLastMessage = i === lastIndex\n              if (!isLastMessage || msg.role !== \"bot\") return msg\n\n              return {\n                ...msg,\n                message: content,\n                sources: [...(msg.sources || []), ...sources],\n              }\n            })\n          })\n          setIsLoading(false)\n        }\n      }\n    } catch (error) {\n      console.error(\"Error during fetch:\", error)\n      setMessages(prev => {\n        const lastIndex = prev.length - 1\n        return prev.map((msg, i) =>\n          i === lastIndex\n            ? {\n                ...msg,\n                message: genericErrorAnswer,\n                pending: false,\n              }\n            : msg,\n        )\n      })\n    } finally {\n      setIsLoading(false)\n      setIsStreaming(false)\n    }\n  }\n\n  return (\n    <ExpandableChat icon={icon}>\n      <ExpandableChatHeader>\n        <h2 className=\"m-0! w-full text-center text-xl font-semibold\">\n          {title}\n        </h2>\n      </ExpandableChatHeader>\n      <ExpandableChatBody\n        style={{\n          scrollbarGutter: \"stable\",\n        }}\n      >\n        {messages.length === 0 && (\n          <PromptSuggestions\n            suggestions={promptSuggestions}\n            onClickSuggestion={handleSendMessage}\n          />\n        )}\n        <ChatMessageList className=\"w-full max-w-3xl\">\n          {messages.map((message, index) => {\n            if (message.role === \"bot\") {\n              const showLoading = isLoading && index === messages.length - 1\n              const isLastMessage = index === messages.length - 1\n              const interruptedStreaming =\n                message.pending && (!isLastMessage || !isStreaming)\n\n              return (\n                <ChatBubble key={index} variant=\"received\">\n                  <ChatBubbleMessage isLoading={showLoading}>\n                    <Markdown references={message.sources}>\n                      {message.message}\n                    </Markdown>\n                    {interruptedStreaming && (\n                      <p className=\"mt-2 text-sm text-muted-foreground\">\n                        {interruptedStreamingError}\n                      </p>\n                    )}\n                  </ChatBubbleMessage>\n                </ChatBubble>\n              )\n            }\n\n            return (\n              <ChatBubble key={index} variant=\"sent\">\n                <ChatBubbleMessage>{message.message}</ChatBubbleMessage>\n              </ChatBubble>\n            )\n          })}\n        </ChatMessageList>\n      </ExpandableChatBody>\n      <ExpandableChatFooter>\n        <div className=\"flex flex-col gap-2 rounded-2xl border p-2\">\n          <ChatInput\n            value={input}\n            onChange={e => setInput(e.currentTarget.value)}\n            placeholder={placeholder}\n            onKeyDown={e => {\n              if (e.key === \"Enter\" && !e.shiftKey) {\n                e.preventDefault()\n                handleSendMessage(input)\n              } else if (e.key === \"Enter\" && e.shiftKey) {\n                e.preventDefault()\n                setInput(input => input + \"\\n\")\n              }\n            }}\n          />\n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"destructive\"\n              size=\"icon-sm\"\n              className=\"cursor-pointer\"\n              onClick={newChat}\n              disabled={messages.length === 0}\n            >\n              <Trash className=\"size-4\" />\n            </Button>\n            <div className=\"flex-grow\" />\n            <Button\n              type=\"submit\"\n              size=\"icon-lg\"\n              className=\"cursor-pointer\"\n              onClick={() => handleSendMessage(input)}\n              disabled={!input || isLoading}\n            >\n              <Send className=\"size-4\" />\n            </Button>\n          </div>\n        </div>\n      </ExpandableChatFooter>\n    </ExpandableChat>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/prompt-suggestions.tsx",
      "content": "import { Button } from \"@/components/ui/button\"\n\ninterface Props {\n  suggestions: string[]\n  onClickSuggestion: (prompt: string) => void\n}\n\nexport default function PromptSuggestions({\n  suggestions,\n  onClickSuggestion,\n}: Props) {\n  if (!suggestions.length) return null\n\n  return (\n    <div className=\"flex h-full w-full items-center justify-center\">\n      <div className=\"flex flex-wrap items-center justify-center gap-4 py-2\">\n        {suggestions.map((prompt, index) => (\n          <Button\n            key={index}\n            variant=\"secondary\"\n            className=\"inline-block h-auto max-w-full cursor-pointer rounded-xl px-4 py-2 text-left leading-snug whitespace-normal\"\n            onClick={() => onClickSuggestion(prompt)}\n          >\n            {prompt}\n          </Button>\n        ))}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:component"
}