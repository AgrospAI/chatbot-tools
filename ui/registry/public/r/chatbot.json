{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "chatbot",
  "title": "Chatbot",
  "description": "A customizable chatbot component.",
  "dependencies": [
    "lucide-react",
    "react-markdown",
    "remark-gfm",
    "react-syntax-highlighter"
  ],
  "registryDependencies": [
    "button",
    "https://agrospai.github.io/chatbot-tools/r/chat.json"
  ],
  "files": [
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/chatbot.tsx",
      "content": "import { Button } from \"@/components/ui/button\"\nimport {\n  ChatBubble,\n  ChatBubbleMessage,\n} from \"@/registry/new-york/chat/components/chat/chat-bubble\"\nimport { ChatInput } from \"@/registry/new-york/chat/components/chat/chat-input\"\nimport { ChatMessageList } from \"@/registry/new-york/chat/components/chat/chat-message-list\"\nimport {\n  ExpandableChat,\n  ExpandableChatBody,\n  ExpandableChatFooter,\n  ExpandableChatHeader,\n} from \"@/registry/new-york/chat/components/chat/expandable-chat\"\nimport Markdown from \"@/registry/new-york/chatbot/components/chatbot/markdown/markdown\"\nimport PromptSuggestions from \"@/registry/new-york/chatbot/components/chatbot/prompt-suggestions\"\nimport { Send, Trash } from \"lucide-react\"\nimport { useState } from \"react\"\n\nexport type Message = UserMessage | BotMessage\n\nexport interface UserMessage {\n  role: \"user\"\n  message: string\n}\nexport interface BotMessage {\n  role: \"bot\"\n  message: string\n  pending: boolean\n  sources: string[]\n}\n\nexport type ChatStrings = {\n  title: string\n  promptSuggestions: string[]\n  placeholder: string\n  interruptedStreamingError: string\n  genericErrorAnswer: string\n}\n\nexport interface ChatbotProps {\n  endpoint?: string\n  strings?: Partial<ChatStrings>\n  messages: Message[]\n  icon?: React.ReactNode\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>\n  newChat?: () => Promise<void>\n}\n\nexport default function Chatbot({\n  endpoint = \"http://localhost:8000/ask\",\n  strings,\n  messages,\n  icon,\n  setMessages,\n  newChat,\n}: ChatbotProps) {\n  const title = strings?.title ?? \"Chatbot Assistant\"\n  const promptSuggestions = strings?.promptSuggestions ?? []\n  const placeholder = strings?.placeholder ?? \"Ask me anything...\"\n  const interruptedStreamingError =\n    strings?.interruptedStreamingError ?? \"(Response was interrupted)\"\n  const genericErrorAnswer =\n    strings?.genericErrorAnswer ??\n    \"Sorry, at this moment I am not able to help you. Try again later.\"\n\n  const [input, setInput] = useState(\"\")\n  const [isLoading, setIsLoading] = useState(false)\n  const [isStreaming, setIsStreaming] = useState(false)\n\n  const handleSendMessage = async (input: string) => {\n    setInput(\"\")\n\n    const userMessage = {\n      role: \"user\",\n      message: input,\n    } as UserMessage\n\n    const botMessage = {\n      role: \"bot\",\n      message: \"\",\n      pending: true,\n    } as BotMessage\n\n    setMessages(messages => [...messages, userMessage, botMessage])\n\n    setIsLoading(true)\n    setIsStreaming(true)\n\n    try {\n      const response = await fetch(endpoint, {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ question: input }),\n      })\n\n      if (!response.ok || !response.body) {\n        throw response.statusText\n      }\n\n      const reader = response.body.getReader()\n      const decoder = new TextDecoder()\n\n      let buffer = \"\"\n      let content = \"\"\n      let sources: string[] = []\n\n      while (true) {\n        const { value, done } = await reader.read()\n        if (done) {\n          break\n        }\n        buffer += decoder.decode(value, { stream: true })\n        const lines = buffer.split(\"\\n\")\n        buffer = lines.pop() || \"\"\n\n        for (const line of lines) {\n          const message = line.replace(/^data: /, \"\").trim()\n          if (!message) continue\n\n          try {\n            const parsed = JSON.parse(message)\n\n            switch (parsed.type) {\n              case \"sources\":\n                sources = parsed.data\n                break\n              case \"token\":\n                content += parsed.data\n                break\n            }\n          } catch (e) {\n            console.error(\"Error parsing JSON chunk\", e)\n          }\n        }\n\n        if (content) {\n          setMessages(prev =>\n            prev.map((msg, i) => {\n              const isLastMessage = i === prev.length - 1\n              if (!isLastMessage || msg.role !== \"bot\") return msg\n\n              return {\n                ...msg,\n                message: content,\n                sources: [...(msg.sources || []), ...sources],\n              }\n            }),\n          )\n          setIsLoading(false)\n        }\n      }\n    } catch (error) {\n      console.error(\"Error during fetch:\", error)\n      botMessage.message = genericErrorAnswer\n    } finally {\n      setMessages(prev =>\n        prev.map((msg, i) =>\n          i === prev.length - 1 ? { ...msg, pending: false } : msg,\n        ),\n      )\n      setIsLoading(false)\n      setIsStreaming(false)\n    }\n  }\n\n  return (\n    <ExpandableChat icon={icon}>\n      <ExpandableChatHeader>\n        <h2 className=\"m-0! w-full text-center text-xl font-semibold\">\n          {title}\n        </h2>\n      </ExpandableChatHeader>\n      <ExpandableChatBody\n        style={{\n          scrollbarGutter: \"stable\",\n        }}\n      >\n        {messages.length === 0 && (\n          <PromptSuggestions\n            suggestions={promptSuggestions}\n            onClickSuggestion={handleSendMessage}\n          />\n        )}\n        <ChatMessageList className=\"w-full max-w-3xl\">\n          {messages.map((message, index) => {\n            if (message.role === \"bot\") {\n              const showLoading = isLoading && index === messages.length - 1\n              const isLastMessage = index === messages.length - 1\n              const interruptedStreaming =\n                message.pending && (!isLastMessage || !isStreaming)\n\n              return (\n                <ChatBubble key={index} variant=\"received\">\n                  <ChatBubbleMessage isLoading={showLoading}>\n                    <Markdown references={message.sources}>\n                      {message.message}\n                    </Markdown>\n                    {interruptedStreaming && (\n                      <p className=\"mt-2 text-sm text-muted-foreground\">\n                        {interruptedStreamingError}\n                      </p>\n                    )}\n                  </ChatBubbleMessage>\n                </ChatBubble>\n              )\n            }\n\n            return (\n              <ChatBubble key={index} variant=\"sent\">\n                <ChatBubbleMessage>{message.message}</ChatBubbleMessage>\n              </ChatBubble>\n            )\n          })}\n        </ChatMessageList>\n      </ExpandableChatBody>\n      <ExpandableChatFooter>\n        <div className=\"flex flex-col gap-2 rounded-2xl border p-2\">\n          <ChatInput\n            value={input}\n            onChange={e => setInput(e.currentTarget.value)}\n            placeholder={placeholder}\n            onKeyDown={e => {\n              if (e.key === \"Enter\" && !e.shiftKey) {\n                e.preventDefault()\n                handleSendMessage(input)\n              } else if (e.key === \"Enter\" && e.shiftKey) {\n                e.preventDefault()\n                setInput(input => input + \"\\n\")\n              }\n            }}\n          />\n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"destructive\"\n              size=\"icon-sm\"\n              className=\"cursor-pointer\"\n              onClick={newChat}\n              disabled={messages.length === 0}\n            >\n              <Trash className=\"size-4\" />\n            </Button>\n            <div className=\"flex-grow\" />\n            <Button\n              type=\"submit\"\n              size=\"icon-lg\"\n              className=\"cursor-pointer\"\n              onClick={() => handleSendMessage(input)}\n              disabled={!input || isLoading}\n            >\n              <Send className=\"size-4\" />\n            </Button>\n          </div>\n        </div>\n      </ExpandableChatFooter>\n    </ExpandableChat>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/prompt-suggestions.tsx",
      "content": "import { Button } from \"@/components/ui/button\"\n\ninterface Props {\n  suggestions: string[]\n  onClickSuggestion: (prompt: string) => void\n}\n\nexport default function PromptSuggestions({\n  suggestions,\n  onClickSuggestion,\n}: Props) {\n  if (!suggestions.length) return null\n\n  return (\n    <div className=\"flex h-full w-full items-center justify-center\">\n      <div className=\"flex flex-wrap items-center justify-center gap-4 py-2\">\n        {suggestions.map((prompt, index) => (\n          <Button\n            key={index}\n            variant=\"secondary\"\n            className=\"inline-block h-auto max-w-full cursor-pointer rounded-xl px-4 py-2 text-left leading-snug whitespace-normal\"\n            onClick={() => onClickSuggestion(prompt)}\n          >\n            {prompt}\n          </Button>\n        ))}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/markdown/markdown.tsx",
      "content": "import styles from \"./markdown.module.css\"\nimport { cn } from \"@/lib/utils\"\nimport ReactMarkdown from \"react-markdown\"\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\"\nimport darkStyle from \"react-syntax-highlighter/dist/esm/styles/prism/one-dark\"\nimport lightStyle from \"react-syntax-highlighter/dist/esm/styles/prism/one-light\"\nimport remarkGfm from \"remark-gfm\"\n\ninterface Props {\n  theme?: \"light\" | \"dark\"\n  children?: string\n  className?: string\n  references?: Array<string>\n}\n\nexport default function Markdown({\n  theme = \"light\",\n  children,\n  className,\n  references = [],\n}: Props) {\n  const hlStyle = theme === \"dark\" ? darkStyle : lightStyle\n\n  return (\n    <div\n      className={cn(\n        \"prose dark:prose-invert flex max-h-fit w-full flex-col\",\n        styles.markdown,\n        className,\n      )}\n    >\n      <ReactMarkdown\n        remarkPlugins={[remarkGfm]}\n        rehypePlugins={[]}\n        urlTransform={uri => uri}\n        components={{\n          code(props) {\n            const { children, className, ...rest } = props\n            const match = /language-(\\w+)/.exec(className ?? \"\")\n            return match ? (\n              <SyntaxHighlighter\n                {...rest}\n                PreTag=\"div\"\n                ref={undefined}\n                language={match[1]}\n                style={hlStyle}\n                customStyle={{\n                  margin: 0,\n                }}\n              >\n                {String(children).replace(/\\n$/, \"\")}\n              </SyntaxHighlighter>\n            ) : (\n              <code {...rest} className={className}>\n                {children}\n              </code>\n            )\n          },\n          a: ({ href, children }) => {\n            if (href?.startsWith(\"ref:\")) {\n              const id = parseInt(href.slice(4))\n              const url = references[id]\n\n              if (!url) return <span>{children}</span>\n\n              return (\n                <a\n                  href={url}\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"ref-button\"\n                >\n                  {children}\n                </a>\n              )\n            }\n\n            return <a href={href}>{children}</a>\n          },\n        }}\n      >\n        {children}\n      </ReactMarkdown>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/registry/new-york/chatbot/components/chatbot/markdown/markdown.module.css",
      "content": ".markdown ul {\n  display: flex;\n  flex-direction: column;\n  margin-top: 0.25rem;\n  margin-bottom: 0.25rem;\n  list-style-type: disc;\n  padding-left: 1rem;\n}\n.markdown ol {\n  margin-top: 0.25rem;\n  margin-bottom: 0.75rem;\n  list-style-type: decimal;\n  padding-left: 1rem;\n}\n.markdown a {\n  color: #3b82f6; /* Tailwind's blue-500 */\n}\n.markdown pre {\n  margin: 0;\n  border: 0;\n  background-color: var(--background);\n  padding: 0;\n}\n.markdown p {\n  margin-bottom: 0.75rem;\n}\n.markdown h1 {\n  margin-bottom: 1rem;\n  font-size: 1.25rem;\n  line-height: 1.25;\n}\n.markdown h2 {\n  margin-bottom: 1.5rem;\n  font-size: 1.125rem;\n  line-height: 1.25;\n}\n.markdown h3 {\n  margin-bottom: 1rem;\n  font-size: 1rem;\n  font-weight: bold;\n  line-height: 1.25;\n}\n.markdown h4 {\n  margin-bottom: 1rem;\n  font-size: 1rem;\n  line-height: 1.25;\n}\n.markdown h5 {\n  margin-bottom: 0.5rem;\n  font-size: 0.875rem;\n  line-height: 1.25;\n}\n.markdown h6 {\n  margin-bottom: 0.5rem;\n  font-size: 0.75rem;\n  line-height: 1.25;\n}\n.markdown hr {\n  margin: 0;\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:component"
}
